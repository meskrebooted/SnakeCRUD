===============================================================================
                    SPIEGAZIONE COMPLETA DEL GIOCO SNAKE
===============================================================================

INDICE:
1. Struttura generale del progetto
2. Come funziona la visualizzazione delle schermate
3. Spiegazione di ogni classe
4. Flusso di gioco completo
5. Meccaniche avanzate

===============================================================================
1. STRUTTURA GENERALE DEL PROGETTO
===============================================================================

Il progetto √® composto da questi file principali:

- Form1.cs           : Logica principale del gioco e gestione UI
- Form1.Designer.cs  : Definizione grafica dei controlli (generato automaticamente)
- Parte.cs           : Classe che rappresenta una singola parte del serpente o il cibo
- Punteggio.cs       : Classe per salvare i punteggi (nome, punti, data, difficolt√†)
- Classifica.cs      : Gestisce l'array di punteggi (CRUD operations)
- DoubleBufferedPanel.cs : Panel ottimizzato per evitare flickering

===============================================================================
2. COME FUNZIONA LA VISUALIZZAZIONE DELLE SCHERMATE
===============================================================================

DOMANDA: "Perch√© sul form si vede solo una schermata alla volta?"

RISPOSTA: Il gioco usa PANNELLI SOVRAPPOSTI con visibilit√† controllata!

Concetto chiave: DOCK e Z-ORDER
--------------------------------
Tutti i pannelli hanno la propriet√† "Dock = Fill", che significa che occupano
TUTTO lo spazio del form. Sono impilati uno sopra l'altro come fogli di carta.

Ordine di aggiunta al form (dal basso verso l'alto):
1. panelMenu         (in fondo)
2. panelScegliColore
3. panelDifficolta
4. panelSalvataggi
5. panelInfoLaterale (solo laterale, non full)
6. panelGame         (in cima)

Come funziona la visibilit√†:
----------------------------
- Tutti i pannelli sono nascosti (Visible = false) tranne quello attivo
- Quando chiami MostraMenu(), nasconde TUTTI i pannelli e mostra solo panelMenu
- Quando chiami MostraGioco(), nasconde TUTTI e mostra panelGame + panelInfoLaterale
- Solo UN pannello principale √® visibile alla volta

Esempio pratico:
----------------
Inizio gioco:
  panelMenu.Visible = true    ‚Üê SI VEDE
  panelGame.Visible = false   ‚Üê NASCOSTO
  panelDifficolta.Visible = false

Clicco "Gioca":
  panelMenu.Visible = false   ‚Üê NASCOSTO
  panelDifficolta.Visible = true ‚Üê SI VEDE QUESTO
  panelGame.Visible = false

√à come avere tanti fogli di carta trasparenti impilati, e decidi quale
rendere opaco (visibile) di volta in volta!

===============================================================================
3. SPIEGAZIONE DI OGNI CLASSE
===============================================================================

3.1 - CLASSE: Parte.cs
----------------------
public struct Parte
{
    public int x;  // posizione orizzontale sulla griglia (0 a larghMax)
    public int y;  // posizione verticale sulla griglia (0 a altMax)
}

Uso:
- Ogni segmento del serpente √® un oggetto Parte
- Il cibo √® un oggetto Parte
- Le coordinate sono CELLE della griglia, non pixel!
  Esempio: x=5, y=3 significa "cella 5 orizzontale, cella 3 verticale"

3.2 - CLASSE: Punteggio.cs
--------------------------
Rappresenta UN singolo record di punteggio salvato.

Propriet√†:
- Nome: string         ‚Üí nome del giocatore
- Punti: int          ‚Üí punteggio ottenuto
- Data: DateTime      ‚Üí quando √® stata fatta la partita
- Difficolta: string  ‚Üí "Facile", "Normale", "Difficile", "Impossibile"

Metodo ToString():
- Formatta il punteggio per visualizzarlo nella lista
- Esempio output: "Mario - 15 punti - Difficile - 16/01/2026 10:30"

3.3 - CLASSE: Classifica.cs
---------------------------
Gestisce la LISTA di tutti i punteggi (array dinamico).

Propriet√†:
- Punteggi: Punteggio[] ‚Üí array che contiene tutti i punteggi
- Count: int           ‚Üí quanti punteggi ci sono

Metodi CRUD:
- Aggiungi(p)  : aggiunge un nuovo punteggio alla fine
- Elimina(i)   : rimuove il punteggio alla posizione i
- (Modifica)   : si fa direttamente modificando Punteggi[i].Nome

IMPORTANTE: Questa classe √® serializzabile in XML!
- [XmlArray] permette di salvare/caricare da file punteggi.xml

3.4 - CLASSE: DoubleBufferedPanel.cs
------------------------------------
Un Panel normale ha flickering (sfarfallio) quando ridisegni frequentemente.
Questo panel attiva il "double buffering":
- Disegna prima su un buffer in memoria
- Poi copia tutto lo schermo in un colpo solo
- Risultato: animazioni fluide senza sfarfallio!

3.5 - CLASSE: Form1.cs (LA PRINCIPALE)
--------------------------------------
Contiene TUTTA la logica del gioco.

Variabili di stato del gioco:
-----------------------------
- serpe[100]      : array dei segmenti del serpente (max 100)
- lung            : lunghezza attuale del serpente
- cibo            : posizione del cibo
- verso           : direzione ("destra", "sinistra", "su", "giu")
- punti           : punteggio attuale
- colSerpe        : colore scelto per il serpente
- difficoltaScelta: difficolt√† scelta ("Facile", "Normale", ecc.)

Timer:
------
- timerGioco : ogni X millisecondi muove il serpente (X dipende dalla difficolt√†)
- timerFPS   : ogni 16ms (~60 FPS) ridisegna lo schermo (animazione fluida)

API Windows (DWM):
------------------
- DwmSetWindowAttribute: API nativa Windows per modificare attributi della finestra
  * DWMWA_USE_IMMERSIVE_DARK_MODE: attiva tema scuro barra del titolo
  * DWMWA_USE_IMMERSIVE_DARK_MODE_BEFORE_20H1: fallback per Windows 10 vecchie versioni
  * Funziona su Windows 10 (20H1+) e Windows 11
  * Rende la barra del titolo nera invece che bianca

Metodi di inizializzazione:
---------------------------
- AbilitaTemaSc(): attiva il tema scuro della barra del titolo Windows
- CreaIconaSerpe(): crea dinamicamente un'icona con emoji serpente üêç
  * Bitmap 32x32 pixel con sfondo trasparente
  * Font "Segoe UI Emoji" per renderizzare l'emoji
  * Converte in icona con Icon.FromHandle()

===============================================================================
4. FLUSSO DI GIOCO COMPLETO (PASSO PASSO)
===============================================================================

FASE 1: AVVIO APPLICAZIONE
---------------------------
1. Form1_Load() viene chiamato
   - Calcola le dimensioni della griglia
   - Carica i punteggi da punteggi.xml
   - Mostra il menu principale

2. Schermata: MENU
   - Visibile: panelMenu
   - Bottoni: GIOCA, PUNTEGGI, ESCI

FASE 2: CLICCO "GIOCA"
-----------------------
3. btnGioca_Click()
   - Chiama MostraDifficolta()

4. Schermata: SELEZIONE DIFFICOLT√Ä
   - Visibile: panelDifficolta
   - Bottoni: üòä FACILE, üòê NORMALE, üòà DIFFICILE, üò± IMPOSSIBILE

FASE 3: SCELGO DIFFICOLT√Ä (es. NORMALE)
----------------------------------------
5. btnDifficolta_Click()
   - Imposta difficoltaScelta = "Normale"
   - Imposta timerGioco.Interval = 100 (velocit√† serpente)
   - Chiama MostraScegliColore()

6. Schermata: SELEZIONE COLORE
   - Visibile: panelScegliColore
   - 36 bottoni colorati disposti in griglia (6 colonne)
   - Colori ordinati per spettro RGB (rosso‚Üíarancio‚Üígiallo‚Üíverde‚Üíblu‚Üíviola)

FASE 4: SCELGO COLORE (es. BLU)
--------------------------------
7. BtnColoreEGioca_Click()
   - Salva il colore scelto in colSerpe
   - Chiama MostraGioco()
   - Chiama AvviaGioco()

8. AvviaGioco()
   - Resetta il serpente: lung=1, posizione iniziale (5,5)
   - Direzione iniziale: "destra"
   - Punti: 0
   - Genera il primo cibo (posizione random)
   - Avvia timerGioco (il serpente inizia a muoversi!)

FASE 5: GIOCO IN CORSO
-----------------------
9. Ogni X millisecondi, timerGioco_Tick() viene chiamato:
   - Chiama MuoviSerpe()
   - Ridisegna lo schermo con Invalidate()

10. MuoviSerpe() - LOGICA PRINCIPALE:
    a) Sposta tutti i segmenti:
       - serpe[1] prende la posizione di serpe[0]
       - serpe[2] prende la posizione di serpe[1]
       - ecc. (dal fondo verso la testa)
    
    b) Muove la testa nella direzione corrente:
       - Se verso = "destra" ‚Üí serpe[0].x++
       - Se verso = "sinistra" ‚Üí serpe[0].x--
       - ecc.
    
    c) CONTROLLO COLLISIONI CON MURI:
       - Se testa fuori dalla griglia ‚Üí FinePartita()
    
    d) CONTROLLO COLLISIONI CON SE STESSO:
       - Se testa tocca un altro segmento ‚Üí FinePartita()
    
    e) CONTROLLO MANGIARE CIBO:
       - Se testa √® sulla posizione del cibo:
         * Aggiungi un segmento al serpente (lung++)
         * Aumenta punti++
         * Genera nuovo cibo in posizione random

11. Input tastiera (Form1_KeyDown):
    - Frecce o WASD: cambiano la direzione del serpente
    - P: torna al menu principale
    - O: apre selezione colori (durante il gioco)

FASE 6: GAME OVER
------------------
12. FinePartita()
    - Ferma timerGioco
    - Mostra messaggio "Hai perso! Punti: X"
    - Mostra campo di testo per inserire nome
    - Mostra bottone "Salva"

13. Inserisco nome e clicco "Salva"
    - btnSalva_Click()
    - Crea un oggetto Punteggio con:
      * Nome inserito
      * Punti ottenuti
      * Data/ora attuale
      * Difficolt√† scelta
    - Aggiunge alla classifica
    - Salva tutto in punteggi.xml
    - Torna al menu principale

===============================================================================
5. MECCANICHE AVANZATE
===============================================================================

5.1 - RENDERING GRAFICO (panelGame_Paint)
-----------------------------------------
Viene chiamato ogni volta che serve ridisegnare (60 volte al secondo!).

Sequenza di disegno:
1. Disegna sfondo a scacchiera (due toni di verde)
   - Pattern checkerboard: (x+y) % 2 decide se cella chiara o scura

2. Disegna OMBRA del serpente (spostata di +2 pixel in basso/destra)
   - Effetto 3D semplice
   - Colore: nero

3. Disegna SERPENTE con il colore scelto
   - Ogni segmento √® un rettangolo di 20x20 pixel

3.5 Disegna OCCHI sulla testa del serpente
   - Due occhi quadrati (5x5 pixel) sulla testa (serpe[0])
   - Posizione varia in base alla direzione del movimento:
     * Destra: occhi sulla parte destra della testa
     * Sinistra: occhi sulla parte sinistra
     * Su: occhi sulla parte alta
     * Gi√π: occhi sulla parte bassa
   - Colore ADATTIVO: calcola luminosit√† del serpente
     * Se colore serpente scuro (luminosit√† < 0.5) ‚Üí occhi BIANCHI
     * Se colore serpente chiaro (luminosit√† ‚â• 0.5) ‚Üí occhi NERI
   - Formula luminosit√†: (0.299*R + 0.587*G + 0.114*B) / 255
     (standard RGB luminosity formula)

4. Disegna OMBRA della mela (stessa tecnica)

5. Disegna MELA (rosso)

6. Disegna FOGLIA E GAMBO sulla mela (dettagli pixelati)
   - Gambo marrone (2x3 pixel) al centro sopra la mela
   - Foglia verde pixelata (pattern 6x4 pixel) intorno al gambo
   - Colori:
     * Gambo: RGB(139, 69, 19) - marrone
     * Foglia: RGB(46, 204, 113) - verde brillante
   - Posizionamento: 3-5 pixel sopra il blocco rosso

Conversione coordinate:
- Coordinate logiche (griglia): serpe[0].x = 5, serpe[0].y = 3
- Coordinate pixel: 5*20 = 100px, 3*20 = 60px

5.2 - PERCH√â DUE TIMER?
-----------------------
Timer 1 (timerGioco):
- Controlla la VELOCIT√Ä del gioco
- Intervallo varia con difficolt√†:
  * Facile: 150ms (lento)
  * Normale: 100ms
  * Difficile: 50ms
  * Impossibile: 15ms (velocissimo!)
- Muove il serpente

Timer 2 (timerFPS):
- SEMPRE 16ms (~60 FPS)
- Ridisegna lo schermo in modo fluido
- Anche se il serpente si muove lento, l'animazione √® fluida

Separare movimento da rendering = animazioni pi√π fluide!

5.3 - SALVATAGGIO XML (PERSISTENZA DATI)
-----------------------------------------
SalvaClassifica():
1. Crea un XmlSerializer per la classe Classifica
2. Apre un FileStream su "punteggi.xml"
3. Serializza l'oggetto classifica ‚Üí XML
4. Il file viene creato/sovrascritto

CaricaClassifica():
1. Controlla se esiste "punteggi.xml"
2. Se s√¨, deserializza il file ‚Üí oggetto Classifica
3. Se no, usa una classifica vuota

Esempio di XML generato:
<?xml version="1.0"?>
<Classifica>
  <Punteggi>
    <Punteggio>
      <Nome>Mario</Nome>
      <Punti>15</Punti>
      <Data>2026-01-16T10:30:00</Data>
      <Difficolta>Difficile</Difficolta>
    </Punteggio>
  </Punteggi>
</Classifica>

5.4 - GESTIONE RESIZE FINESTRA
-------------------------------
panelGame_Resize():
- Quando ridimensioni la finestra, ricalcola larghMax e altMax
- La griglia si adatta automaticamente!
- Formula: larghMax = larghezza_panel / 20
           altMax = altezza_panel / 20

5.5 - CREAZIONE DINAMICA BOTTONI COLORE
---------------------------------------
CreaBottoniColore():
- Crea 36 bottoni colorati PROGRAMMATICAMENTE
- Calcola posizione in griglia (6 colonne)
- Formula posizione:
  * X = startX + (indice % 6) * (larghezza + spaziatura)
  * Y = startY + (indice / 6) * (altezza + spaziatura)
- Ogni bottone ha lo stesso evento Click

Esempio calcolo:
Bottone indice 7:
- Colonna: 7 % 6 = 1 (seconda colonna)
- Riga: 7 / 6 = 1 (seconda riga)
- X = 200 + 1 * 110 = 310
- Y = 150 + 1 * 70 = 220

5.6 - INTERFACCIA UTENTE E TEMA SCURO
--------------------------------------
Colori dell'interfaccia:
- Sfondi menu: RGB(35, 35, 35) - grigio molto scuro
- Bottoni punteggi: RGB(60, 60, 60) - grigio scuro
- Hover bottoni: RGB(80, 80, 80) - grigio medio
- Label info: RGB(50, 50, 50) - grigio scuro
- Bottone impossibile: RGB(35, 35, 35) con bordo rosso
- Testo: bianco per contrasto

Tema scuro barra del titolo:
- Usa API Windows DWM (Desktop Window Manager)
- Richiede Windows 10 versione 20H1 o superiore, oppure Windows 11
- Se fallisce su versioni vecchie, prova il fallback (BEFORE_20H1)
- Rende la finestra completamente dark mode

Icona dinamica:
- Creata a runtime (non file .ico)
- Usa emoji nativa del sistema operativo
- Si adatta automaticamente alla risoluzione
- Colore verde per richiamare il serpente del gioco

===============================================================================
6. DOMANDE FREQUENTI E RISPOSTE
===============================================================================

Q: Perch√© l'array serpe √® di 100 elementi?
A: √à il massimo numero di segmenti che il serpente pu√≤ avere.
   Ogni cibo mangiato aggiunge 1 segmento, quindi 100 cibi = game completo.

Q: Come fa il serpente a non tornare indietro?
A: Nel codice di controllo input c'√®: if (verso != "destra") verso = "sinistra"
   Questo impedisce di andare sinistra se stai andando a destra!

Q: Perch√© quando clicco O durante il gioco si apre la selezione colori?
A: Form1_KeyDown controlla se panelGame.Visible √® true, e se premi O
   ferma il timer e chiama MostraScegliColore().

Q: Come funziona la collisione con se stesso?
A: Un ciclo controlla se la testa (serpe[0]) ha le stesse coordinate
   di qualsiasi altro segmento (serpe[1]...serpe[lung-1]).

Q: Perch√© ci sono due file Form1.cs e Form1.Designer.cs?
A: Form1.Designer.cs contiene SOLO il codice auto-generato dal designer visuale.
   Form1.cs contiene la logica che scrivi tu.
   NON modificare mai manualmente il Designer.cs!

Q: Come funziona il calcolo della luminosit√† per gli occhi adattivi?
A: Usa la formula standard RGB luminosity:
   luminosit√† = (0.299 √ó R + 0.587 √ó G + 0.114 √ó B) / 255
   I coefficienti pesano di pi√π il verde perch√© l'occhio umano √® pi√π sensibile.
   Se luminosit√† < 0.5 (colore scuro) ‚Üí occhi bianchi per contrasto.

Q: Perch√© gli occhi cambiano posizione?
A: Per dare l'illusione che il serpente guardi nella direzione del movimento!
   √à un dettaglio visivo che rende il gioco pi√π "vivo" e piacevole.

Q: Come √® stata creata la foglia pixelata della mela?
A: √à composta da 4 rettangoli verdi (3x2 pixel ciascuno) disposti a croce,
   pi√π un gambo marrone centrale (2x3 pixel). Tutto posizionato sopra il
   blocco rosso della mela per simulare una mela pixelata stile retro-gaming.

Q: Come funziona la selezione multipla nella classifica?
A: La ListBox usa SelectionMode.MultiExtended che permette:
   - Click singolo: seleziona una persona
   - Ctrl+Click: seleziona pi√π persone una alla volta
   - Shift+Click: seleziona un range di persone
   Il bottone "Elimina" pu√≤ eliminare pi√π persone contemporaneamente,
   il bottone "Modifica" funziona solo con 1 persona selezionata.

Q: Come funziona la modifica del nome senza finestra dialogo?
A: Invece di aprire InserisciNomeForm (finestra volante), quando clicchi "Modifica":
   1. Appare una TextBox (txtModificaNome) e bottone "Conferma" nella stessa schermata
   2. La TextBox viene precompilata col nome attuale
   3. Il testo viene selezionato automaticamente per modificare velocemente
   4. L'indice del punteggio viene salvato nel Tag della TextBox
   5. Cliccando "Conferma" o premendo Enter, salva la modifica
   6. TextBox e bottone scompaiono dopo la modifica
   Questo rende l'interfaccia pi√π fluida e integrata senza popup.

===============================================================================
FINE SPIEGAZIONE
===============================================================================
